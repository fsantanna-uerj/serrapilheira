\label{sec.introduction}

According to the International Energy Agency (IEA), the number of
network-connected devices is expected to reach 50 billion by 2020 with the
expansion of the Internet of Things (IoT)~\cite{iea.data}.
%
However, most of the energy to power these devices will be consumed in
\emph{standby mode}, i.e., when they are neither transmitting or processing
data.
%
For instance, standby power currently accounts for 10--15\% of residential
electricity consumption, and $CO_2$ emissions related to standby are equivalent
to those of 1 million cars~\cite{iea.data,standby.australia}.
%
The projected growth of IoT devices, together with the surprising effects of
standby consumption, made network standby efficiency one of the six
pillars of the G20's \emph{Energy Efficiency Action Plan}%
\footnote{G20's Energy Efficiency Action Plan: \url{https://www.iea-4e.org/projects/g20}}.

Given the projected scale of the IoT and the role of low-power standby towards
energy efficiency, this paper has the following goals:

\begin{enumerate}
\item Address energy efficiency through extensive use of standby.
\item Target low-power, resource-constrained embedded architectures that form
      the IoT.
\item Provide standby mechanisms at the programming language level that scale
      to all applications.
\item Support transparent/non-intrusive standby mechanisms that reduce barriers
      of adoption.
\end{enumerate}

Our approach lies at the bottom of the software development
layers---programming language mechanisms---meaning that \emph{all} applications
take advantage of low-power standby modes automatically, without extra
programming efforts.
%
We extend the synchronous programming language
\CEU~\cite{ceu.sensys13,ceu.tecs17} with support for interrupt service routines
(ISRs) and with a simple power management runtime (PMR).
%
Each supported microcontroller requires bindings in C for the ISRs and PMR, and
each peripheral requires a driver in \CEU.
These are a one-time procedures and are typically packaged and distributed in a
software development kit (SDK).
%
Then, all new applications built on top of these drivers take advantage of
standby automatically.
%
As a proof of concept, we provide an open source SDK %
%\footnote{https://github.com/fsantanna/ceu-arduino/}
with support for 8-bit
\emph{AVR/ATmega} and 32-bit \emph{ARM/Cortex-M0} microcontrollers, and a
variety of peripherals, such as GPIO, A/D converter, USART, SPI, and the nRF24L01
transceiver.

We developed a number of applications using these peripherals concurrently and
could verify that the applications remain in deepest standby modes for longest
periods of time.
%
We also compare the structure of programs in \CEU and
Arduino~\cite{arduino.book}, whose primary goal is to reduce the barrier of
adoption for non-technical users (e.g., designers and artists).
We show that we can keep the intended sequential reasoning of Arduino even when
applications require non-trivial concurrent behaviors.

% - standby as well as enabled/disabled, powered, switched
% - application on IoT
% - results
%   - atmega 328p/2560
%   - arm cortex-m0
%   - how much efficiency?
% - limitations

%In Section~\ref{sec.ceu}, we introduce the structured synchronous model and the
%programming language \CEU.
%In Section~\ref{sec.apps}, we evaluate .
%In Section~\ref{sec.ext}, we present the language extensions that support
%transparent standby.

\section{The Structured Synchronous Programming Language \CEU}

\begin{comment}
- structured programming
- lexical scope

In summary:

Reactive: code executes in reactions to events

Synchronous: reactions run to completion, i.e., there's no implicit preemption or real parallelism (this avoids explicit synchronization: locks, queues, etc)

Structured: programs use structured control mechanisms, such as "await" (to suspend a line of execution), and "par" (to combine multiple awaiting lines of execution)

Structured programming avoids deep nesting of callbacks letting you write programs in direct/sequential style. In addition, when a line of execution is aborted, all allocated resources are safely released.

In comparison to FRP/dataflow, it is more imperative supporting sequences/loops/conditionals/parallels. The notion of (multiple) program counter is explicit. Also, everything is lexically scoped, there's no GC involved.

In comparison to promises/futures, it provides lexical parallel constructs, allowing the branches to share local variables and, more importantly, supporting safe abortion of code (with the "par/or").
\end{comment}

\CEU is a Esterel-based\cite{ceu.tecs17} reactive programming language
targeting resource-constrained embedded systems~\cite{ceu.sensys13}.
%
It is grounded on the synchronous concurrency model, which has been
successfully adopted in the context of hard real-time systems such as avionics
and automobiles industry since the 80's~\cite{rp.twelve}.
%
The synchronous model trades power for reliability and has a simpler model
of time that suits most requirements of IoT applications.
%
On the one hand, this model cannot directly express time-consuming
computations, such as compression and cryptography algorithms, which are
typically either absent or delegated to auxiliary chips in the context of the
IoT.
%
On the other hand, all reactions to the external world are guaranteed to be
computed in bounded time, ensuring that applications always reach an idle state
amenable to standby mode.
%
Overall, \CEU aims to offer a concurrent, safe, and expressive alternative to C
with the characteristics that follow:
%
\begin{description}
\item [Reactive:] code only executes in reactions to events.
\item [Structured:] programs use structured control mechanisms, such as
    \code{await} (to suspend a line of execution), and \code{par} (to combine
    multiple lines of execution).
\item [Synchronous:] reactions run atomically and to completion on each line of
    execution, i.e., there's no implicit preemption or real parallelism.
\end{description}
%
Structured reactive programming lets developers write code in direct style,
recovering from the inversion of control imposed by event-driven
execution~\cite{rp.deprecating,rp.rescala,sync_async.cooperative}.

\subsection*{A Motivating Example}
\label{sec.ceu.example}

{\linespread{1}
\begin{figure}[t]
\begin{minipage}[t]{0.49\linewidth}
\begin{lstlisting}[xrightmargin=0.5cm]
while (1) {
  delay(1000);
  int v =
    analogRead(A0);
  radioWrite(v);
}
\end{lstlisting}
\centering\small{[a] Version in Arduino}
\end{minipage}
%
\begin{minipage}[t]{0.49\linewidth}
\begin{lstlisting}[numbers=left,xleftmargin=-0.2cm]
loop do
  await 1s;
  var int v =
    await AnalogRead(A0);
  await RadioWrite(v);
end
\end{lstlisting}
\centering\small{[b] Version in \CEU}
\end{minipage}
%\rule{8.4cm}{0.37pt}
\caption{ Sequence of I/O operations running in a loop.
\label{lst.direct}
}
\end{figure}
}

Figure~\ref{lst.direct}.a shows a simple, easy-to-read program chunk in Arduino
that executes forever in a loop a sequence of operations as follows:
    waits for 1 second (ln. 2),
    performs an A/D conversion (ln. 3--4), and
    broadcasts the value read (ln. 5).
%
Figure~\ref{lst.direct}.b shows the same chunk in \CEU, with a noteworthy
difference that operations that interact with the environment and take time use
the \code{await} keyword. % and can be easily identified in the program.
%
The traditional structured paradigm encouraged in Arduino (with blocks, loops,
and sequences) allows for simple and readable code, avoiding the complexity of
dealing with ISRs.
%
However, the use of blocking operations, such as \code{delay(1000)}, prevents
that other operations execute concurrently.

Suppose we now want that, at any time, receiving a message via radio should
immediately abort the loop in Figure~\ref{lst.direct}.a.
%
Since the message might arrive concurrently with any of the blocking
operations, we need to change the structure of the program.
%
Figure~\ref{lst.inversion}.a changes the blocking operation \code{delay} to the
polling operation \code{millis}, which immediately returns the number of
milliseconds since the reset.
Now, we start by registering the current time (ln. 1--2) and, on each loop
iteration, we recheck the time to see if one second has elapsed (ln. 7--9).
Since these operations are non-blocking, we can intercalate the execution with
checks for message arrivals (ln. 4--6).
If the time is up, we start counting it again (ln. 10) before proceeding to the
original operations in sequence (ln. 11--13).
%
The original structured style has been drastically violated to accommodate
concurrency.
In the example, we only adapted the \code{delay} operation, but the other
blocking operations (\code{analogRead} and \code{radioWrite}) would also need
to be changed to achieve maximum concurrency.
%
Alternatively, we could resort to ISRs or implement an event-driven
scheduler to handle the operations~\cite{tos.nesc}, but ultimately, the
program readability would still be compromised.

The program in Figure~\ref{lst.inversion}.b in \CEU extends the one in
Figure~\ref{lst.direct}.b to accommodate concurrency.
%
The original code remains unmodified (ln. 4--9) and concurrency is achieved
through the \code{par/or} construct, which creates two lines of execution and
terminates when either of them terminates, aborting the other automatically.
%
This approach preserves the sequential, easy-to-read style while accommodating
concurrency seamlessly.

\begin{figure}[t]
\begin{minipage}[t]{0.49\linewidth}
\begin{lstlisting}[xrightmargin=0.5cm]
uint32_t prv =
  millis();
while (1) {
  if (radioAvail()) {
    break;
  }
  uint32_t cur =
    millis();
  if (cur>prv+1000) {
    prv = cur;
    int v =
      analogRead(A0);
    radioWrite(v);
  }
}
\end{lstlisting}
\centering\small{[a] Version in Arduino}
\end{minipage}
%
\begin{minipage}[t]{0.49\linewidth}
\begin{lstlisting}[numbers=left,xleftmargin=-0.2cm]
par/or do
  await RadioAvail();
with
  loop do
    await 1s;
    var int v =
      await AnalogRead(A0);
    await RadioWrite(v);
  end
end




.
\end{lstlisting}
\centering\small{[b] Version in \CEU}
\end{minipage}
%\rule{8.4cm}{0.37pt}
\caption{ Achieving concurrency between I/O operations.
\label{lst.inversion}
}
\end{figure}

\subsection*{Standby Considerations}
\label{sec.ceu.standby}

The structure of the program in Figure~\ref{lst.inversion}.b also indicates
which peripherals are active at a given time.
%
For instance, when the program is awaiting concurrently in lines 2 and 7,
only the radio transceiver and A/D converter can awake the program.
Hence, the language runtime can choose the most energy-efficient sleep mode
that allows these peripherals to awake the microcontroller from associated
interrupts.
%
Since the semantics of \CEU enforces the program to always reach \code{await}
statements in all active lines of execution, it is always possible to put the
microcontroller into the optimal sleep mode after each reaction to the
environment.

\section{Transparent Standby Mechanisms}
\label{sec.ceu}

\begin{figure}[t]
\begin{lstlisting}[numbers=left]
output (int pin) ANALOG_REQUEST do
    <...>   // port manipulation to start the conversion
end

async/isr ADC_vect_num do
    var int value = <...>; // port with the value read
    emit ANALOG_DONE(value);
end

code AnalogRead (var int pin) -> int do
    {PM_SET(PM_ANALOG, 1);}
    do finalize with
        {PM_SET(PM_ANALOG, 0);}
    end

    emit ANALOG_REQUEST(pin);
    var int value = await ANALOG_DONE;

    escape value;
end
\end{lstlisting}
%\rule{8.4cm}{0.37pt}
\caption{ \CEU driver for the A/D converter.
\label{lst.adc}
}
\end{figure}

\begin{figure}[t]
\begin{lstlisting}[numbers=left]
#define PM_GET(peripheral)       bitRead(pm, peripheral)
#define PM_SET(peripheral,state) bitWrite(pm, peripheral, state);

static u32 pm = 0;

void pm_sleep (void) {
  if (PM_GET(PM_TIMER1) || PM_GET(PM_USART) || PM_GET(PM_SPI)) {
      LowPower.idle(PM_GET(PM_ADC),...)
    } else if (PM_GET(PM_ADC)) {
      LowPower.adcNoiseReduction(...);
    } else {
      LowPower.powerDown(...);
    }
  }
}
\end{lstlisting}
%\rule{8.4cm}{0.37pt}
\caption{ Power management module for the ATmega328p microcontroller.
\label{lst.pm}
}
\end{figure}


\begin{acks}
  The authors would like to thank Dr. Yuhua Li for providing the
  MATLAB code of the \textit{BEPS} method.

  The authors would also like to thank the anonymous referees for
  their valuable comments and helpful suggestions. The work is
  supported by the \grantsponsor{GS501100001809}{National Natural
    Science Foundation of
    China}{http://dx.doi.org/10.13039/501100001809} under Grant
  No.:~\grantnum{GS501100001809}{61273304}
  and~\grantnum[http://www.nnsf.cn/youngscientists]{GS501100001809}{Young
    Scientists' Support Program}.

\end{acks}
